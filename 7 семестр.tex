\documentclass[a4paper,14pt]{extreport}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{eqnarray}
\usepackage{color,colortbl}
\definecolor{Gray}{gray}{0.9}
\linespread{1.3}
\parindent=1cm
\usepackage[left=3cm, right=1.5cm, top=2cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{indentfirst}
\usepackage{url}
\makeatletter
\usepackage{tocloft}

\renewcommand{\cftaftertoctitle}{\mbox{}\hfill \\ \mbox{}\hfill{\footnotesize Стр.}\vspace{-2.5em}}

\setcounter{tocdepth}{2} % задать глубину оглавления — до subsection включительно
\usepackage{titlesec}
\titleformat{\chapter}[display]{\filcenter}{\large\MakeUppercase{\chaptertitlename} \thechapter}{8pt}{\large\bfseries}{}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{18pt}
\titlespacing*{\section}{\parindent}{18pt}{18pt}
\titlespacing*{\subsection}{\parindent}{18pt}{18pt}
\renewcommand{\@biblabel}[1]{#1.\hfil}
\renewcommand\contentsname{ОГЛАВЛЕНИЕ}
\renewcommand\bibname{СПИСОК ЛИТЕРАТУРЫ}
\oddsidemargin=0 cm
\textwidth=17 cm
\textheight=24 cm
\topmargin=0 cm
\headheight=0 cm
\headsep=0 cm

\parindent=0.5 cm

\makeatletter
\renewcommand{\@biblabel}[1]{#1.}
\makeatother


\begin{document}
\begin{titlepage}
\begin{center}
\large
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ

БУРЯТСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

Институт математики и информатики

Кафедра прикладной математики

\vspace{2 cm}

\textsc{Курсовая работа}

\vspace{1.5 cm}

{\LARGE 3D-визуализация\\
двумерного плана помещения\\
методом бросания лучей}
\end{center}

\vspace{3 cm}
\begin{table}[h!]
\begin{tabular}{p{0.5\linewidth}l}
\hfill Выполнил :     & студент 4 курса группы 05230\\
                             & Шорников Александр Евгеньевич\\
\hfill Научный руководитель: & асс. каф. ИТ \\
                             & Брагин Александр Фёдорович\\


\end{tabular}
\end{table}


\vspace{\fill}
\vspace{\fill}
\begin{center}
Улан-Удэ \\ 2016
\end{center}
\end{titlepage}


\newpage    %Это оглавление
\setcounter{page}{2}
\tableofcontents{}


\newpage    %Это введение
\addcontentsline{toc}{chapter}{Введение}
\chapter*{ВВЕДЕНИЕ}
\hspace{\parindent}Представление данных на мониторе компьютера в графическом виде впервые было реализовано в середине
50-х годов для больших ЭВМ, применявшихся в научных и военных исследованиях. С тех пор графический способ отображения
данных стал неотъемлемой принадлежностью подавляющего числа компьютерных систем, в особенности персональных. Графический
интерфейс пользователя сегодня является стандартом “де-факто” для программного обеспечения разных классов, начиная с
операционных систем\cite{start1}.\\

Существует специальная область информатики, изучающая методы и средства создания и обработки изображений с помощью
программно-аппаратных вычислительных комплексов - компьютерная графика\cite{veldmanter}. Она охватывает все виды и формы
представления изображений, доступных для восприятия человеком либо на экране монитора, либо в виде копии на
внешнем носителе (бумага, кинопленка, ткань и прочее). Без компьютерной графики невозможно представить себе
не только компьютерный, но и обычный, вполне материальный мир. Визуализация данных находит применение в самых
разных сферах человеческой деятельности. Для примера назовем медицину (компьютерная томография), научные
исследования (визуализация строения вещества, векторных полей и других данных), моделирование тканей и одежды,
опытно-конструкторские разработки.\\

Отдельным предметом считается трехмерная (3D) графика, изучающая приемы и методы построения объемных моделей
объектов в виртуальном пространстве. Как правило, в ней сочетаются векторный и растровый способы формирования
изображений. \\

Также, заметное место в компьютерной графике отведено развлечениям. Появилось даже такое понятие, как механизм графического
представления данных (Graphics Engine). Рынок игровых программ имеет оборот в десятки миллиардов долларов и часто
инициализирует очередной этап совершенствования графики и анимации.\\

Хотя компьютерная графика служит всего лишь инструментом, ее структура и методы основаны на передовых
достижениях фундаментальных и прикладных наук: математики, физики, химии, биологии, статистики, программирования
и множества других. Это замечание справедливо как для программных, так и для аппаратных средств создания и
обработки изображений на компьютере. Поэтому компьютерная графика является одной из наиболее бурно развивающихся
отраслей информатики и во многих случаях выступает “локомотивом”, тянущим за собой всю компьютерную индустрию.\\

\textbf{Задачи} данной курсовой работы:\\
- выбор и изучение темы <<Метод бросания луча>>;\\
- убедиться в возможности реализации;\\
- убедиться применимости для решения задачи проекта;\\
- реализовать простейший прототип.\\

 \textbf{Объектом} исследования данной курсовой работы является
 задача построения псевдотрёхмерной картинки.\\

 \textbf{Предметом} исследования данной курсовой работы является
 изучение основных принципов построения псевдотрёхмерной картинки
 методом бросания луча.

\newpage    %1 глава
\chapter{Технологии рендеринга}
Метод бросания лучей(англ. Raycasting, "Рейкастинг") - это технология получения изображения по модели с помощью компьютерной
программы, позволяющая создавать 3D перспективу в 2D картах\cite{raycast}.
В те времена, когда компьютеры были намного медленнее, чем сейчас, и механизмы 3D невозможно было запустить в реальном времени,
рейкастинг был единственным возможным решением. Рейкастинг может работать очень быстро, поскольку он предполагает только выполнение
необходимых вычислений для каждой вертикальной линии на экране. Самая известная игра с применением рейкастинга - это, конечно же,
компьютерная игра \textit{Wolfenstein 3D}.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=10cm]{ris1_1}\\
\caption{Скриншот игры \textit{Wolfenstein 3D}}
\end{center}
\end{figure}

\textit{Wolfenstein 3D engine} — псевдотрёхмерный игровой движок, разработанный для игры \textit{Wolfenstein 3D},
вышедшей 5 мая 1992 года. Движок разрабатывался преимущественно Джоном Кармаком, главным программистом компании id Software. Движок
\textit{Wolfenstein 3D engine} реализует VGA графику (рейтранслитинговая), звук (WAV и IMF), физику и управление. Написан на Си и ассемблере x86.\\
Возможности компьютеров с процессором Intel 80286, которые были тогда распространены, были крайне ограничены\cite{start2}. Для рендеринга изображения
при помощи рейкастинга в игре \textit{Wolfenstein 3D} движок игры был специальным образом оптимизирован для слабых вычислительных машин.
В результате чего все стены в этой игре имеют одинаковую высоту, и представляют собой взаимно перпендикулярные ячейки 2D сети, как видно на рисунке 1.2:

\begin{figure}[h!]
\begin{center}
\includegraphics[width=10cm]{ris1_2}\\
\caption{Скриншот игры \textit{Редактор уровней Wolfenstein 3D}}
\end{center}
\end{figure}

К сожалению, графические движки на основе технологии рейкастинга слишком слабы, что бы реализовать такие элементы, как лестницы или
прыжки с разницей высот. Независимые графические объекты, свободно перемещающиеся по экрану (противники, внутреигровые объекты и
прочее) представляют собой не трёхмерные объекты, а двухмерные картинки-спрайты. Более поздние игры на этой технологии,
такие как \textit{Doom} и \textit{Duke Nukem 3D} были гораздо более продвинутыми, и
позволяли создавать наклонные стены (поверхности), разницу высот, текстурированные полы и потолки, прозрачные стены и т.д., но в них
 были использованны разные технологии помимо рейкастинга, поэтому в рамках данной курсовой работы они не представляют интереса\cite{start3}.\\

\newpage    %2 глава
\chapter{Описание метода}
Основная идея рейкастинга состоит в следующем: карта представляет собой 2D-решетку с квадратными ячейками (двухмерный массив),
где значением каждой ячейки может быть равно 0, что означает отсутствие стены, либо положительное число, означающее стену
определенного цвета или текстуры. \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=15cm]{ris2_1}\\
\caption{Пример уровня карты}
\end{center}
\end{figure}

Каждому значению х на экране (для каждой вертикальной линии на экране) соответствует луч,
который исходит из местонахождения игрока и направление которого зависит от двух критериев: направление взгляда игрока и
координата х на экране. Затем данный луч начинается двигаться вперед по 2D карте до тех пор, пока не упрется в ячейку карты,
которая является стеной. Если он пересечётся со стеной, то будет рассчитываться расстояние от этой точки соприкосновения со
стеной до игрока, которое поможет определить, насколько высоко стену нужно будет переместить на экране: чем дальше распложена
стена, тем меньше будет ее изображение на экране, и наоборот. Это - все 2D расчёты\cite{laslo}. На рисунке 2.2 в ракурсе <<сверху вниз>>
представлены два луча (выделены красным), которые исходят от игрока зеленя точка) и упираются в синюю стену.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=4cm]{ris2_2}\\
\caption{Бросание луча}
\end{center}
\end{figure}

Чтобы обнаружить первую стену, которую луч встречает на своем пути, необходимо, чтобы он исходил из точки местоположения
игрока, а затем нужно все время проверять, не находится ли луч внутри стены. Если он оказывается внутри стены (упирается в неё),
цикл можно завершить, рассчитать расстояние и нарисовать стену правильной высоты. Если же луч не упирается в стену,
необходимо продолжать вести его: добавить определённую величину к его положению, в направлении направления данного луча, и
проверить, не находится ли луч в новом положении внутри стены. Проделывать данные действия необходимо до тех пор, пока
луч не коснется стены. \\

Человек может сразу же увидеть, касается ли луч стены, но невозможно сразу же рассчитать, какой именно ячейки луч касается,
используя всего одну формулу, поскольку компьютер может осуществить проверку ограниченного количества положений луча.
Многие рейкастовые движки добавляют постоянную величину к лучу на каждом этапе, но в этом случае существует вероятность
того, что луч может "промахнуться" и не коснуться стены. Например, положение этого красного луча проверялось в каждой красной точке.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=4cm]{ris2_3}\\
\caption{Луч дошёл до стены}
\end{center}
\end{figure}

Как вы можете видеть на рисунке 2.3, луч проходит прямо через синюю стену, но компьютеру не удалось это определить, поскольку
он осуществлял только проверки красных точек. Чем большее количество положений проверяется, тем менее вероятность того,
что компьютер не определит стену, но тем больше вычислений понадобится выполнить. На рисунке 2.4 показано, что расстояние
между шагами было уменьшено вдвое, и компьютером было определено, что луч проходит через стену, хотя его положение и не совсем верно.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=4cm]{ris2_4}\\
\caption{Уменьшение числа проверок на столкновение}
\end{center}
\end{figure}

Для повышения точности данного метода необходимо бесконечно малое расстояние между точками, и, таким образом, необходимо будет
производить бесконечное количество вычислений. Это неудобно, но, к счастью, существует более подходящая методика, предполагающая
выполнение лишь нескольких вычислений и позволяющая определить каждую из стен. Идея состоит в следующем: проверять факт наличие
луча на каждой из сторон стены. При ширине каждой ячейки, равной 1, каждая из сторон стены будет целым числом, а места между
стенами будут равны некоему числу с цифрами после запятой. В этом случае размер шага не является постоянной величиной, он зависит
от расстояния до следующей стороны ячейки.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=4cm]{ris2_5}\\
\caption{Проверка на каждой из сторон стены }
\end{center}
\end{figure}

Как видно на рисунке 2.5, луч касается стены именно там, где нам это необходимо. В способе используется алгоритм, основанный на
цифровом дифференциальном анализе. Цифровой Дифференциальный Анализ(Digital Differential Analysis, DDA) - скоростной алгоритм, обычно применяемый при использовании
квадратной решётки, позволяющий определить, какие ячейки задевает луч (например, чтобы нарисовать линию на экране, состоящем из
решётки квадратных пикселей)\cite{nikulin}. Таким образом, можно использовать этот метод, чтобы определить, какие ячейки решётки на
нашем экране оказываются задеты лучом, и приостановить алгоритм, как только луч коснется ячейки, являющейся стеной.\\

Некоторые рейтрейсеры работают с Евклидовыми углами, которые представляют направление взгляда игрока и лучей, и позволяют задать
Обзор (Поле Зрения) с помощью другого угла. Тем не менее, я обнаружил, что вместо этого намного проще работать с векторами и
камерой: положение игрока всегда является вектором (с координатами $x$ и $y$), но теперь можно также определить направление
вектора: его направление определяется с помощью двух величин (координат $x$ и $y$ направления). Вектор направления можно
визуализировать следующим образом: если нарисуем линию в направлении взгляда игрока, проходящую через точку нахождения игрока,
то каждая точка данной линии будет являться суммой показателей положения игрока и будет кратна направлению вектора (показателям
направления вектора). Длина вектора направления не имеет особого значения, важно лишь его направление. Умножение показателей
$x$ и $y$ на одну и ту же величину изменяет длину, но сохраняет направление вектора\cite{jozeph}.\\

Данный векторный метод также требует наличие дополнительного вектора, представляющего собой вектор плоскости камеры. В настоящем
3D движке также имеется плоскость камеры, и там она является настоящей 3D плоскостью, которую должны представлять два вектора
($u$ и $v$). Рейкастинг рассчитан на 2D карты, потому в этом случае плоскость камеры не является плоскостью, это скорее линия,
представленная одним вектором. Плоскость камеры всегда должна быть перпендикулярна вектору направления. Плоскость камеры
представляет собой плоскость на компьютерном экране, в то время как вектор направления расположен перпендикулярно по отношению
к этой плоскости и направлен  внутрь экрана. Положение игрока представлено одной точкой, расположенной перед плоскостью камеры.
Определённый луч определённых $x$-координат на экране является, в таком случае, лучом, который начинается в точке нахождения
игрока и проходит через это положение или через плоскость камеры.\\
\begin{figure}[h!]
\begin{center}
\includegraphics[width=6cm]{ris2_6}\\
\caption{Визуализация 2D-камеры}
\end{center}
\end{figure}
На рисунке 2.6 представлена такая 2D камера. Зеленая точка - это положение (вектор $\overrightarrow{pos}$). Чёрная линия,
оканчивающаяся чёрной точкой, представляет вектор направления (вектор $\overrightarrow{dir}$). Таким образом, положение
чёрной точки  - это вектор $\overrightarrow{pos}+\overrightarrow{dir}$. Синяя линия представляет полную плоскость камеры.
Вектор, проходящий от чёрной точки к правой синей точке представляет вектор $\overrightarrow{plane}$. Таким образом,
положение правой синей точки - $\overrightarrow{pos}+\overrightarrow{dir}+\overrightarrow{plane}$, а положение левой
синей точки - $\overrightarrow{pos}+\overrightarrow{dir}-\overrightarrow{plane}$ (все это - векторное сложение).\\

Красные линии на изображении - это несколько лучей. Направление этих лучей легко можно рассчитать с помощью камеры: это - сумма
вектора направления камеры и части вектора плоскости камеры. Например, третий красный луч на рисунке проходит сквозь правую часть
плоскости камеры в точке, составляющей приблизительно $1/3$ от её длины. Таким образом, направление этого луча рассчитывается по
формуле $\overrightarrow{dir} + \overrightarrow{plane} \cdot 1/3$. Направление этого луча - это вектор $\overrightarrow{rayDir}$, а
компоненты $x$ и $y$ данного вектора далее будут использоваться в алгоритме цифрового дифференциального анализа.\\

Две другие лини являются левой и правой границей экрана, а угол между этими двумя линиями называется углом обзора. Угол обзора
 определяется по соотношению длины вектора направления и длины плоскости. Вот несколько примеров различных углов обзора:\\

Если вектор направления и вектор плоскости камеры имеют одинаковую длину, угол обзора будет равен 90°:\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=6cm]{ris2_7}\\
\caption{Угол обзора 90°}
\end{center}
\end{figure}

Если вектор направления намного длиннее вектора плоскости камеры, значение угла обзора будет намного меньше 90°, и поле обзора
будет очень маленьким, игрок будет видеть все более детально, но с меньшей глубиной, что напоминает приближение камеры для получения
изображения крупным планом. \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=3cm]{ris2_8}\\
\caption{Угол обзора меньше 90°}
\end{center}
\end{figure}

Если вектор направления короче вектора плоскости камеры, значение угла обзора будет превышать 90° (180° - максимальная величина,
если вектор направления равен 0). В этом случае игрок будет иметь гораздо более широкое поле обзора, как при отдалении камеры. \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=6cm]{ris2_9}\\
\caption{Угол обзора больше 90°}
\end{center}
\end{figure}

При вращении игрока камера также должна вращаться(рис. 2.10), следовательно, и вектор направления, и вектор плоскости камеры также должны
поворачиваться вместе с ними. Далее все остальные лучи будут вращаться автоматически. \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=6cm]{ris2_10}\\
\caption{Поворот 2D камеры}
\end{center}
\end{figure}

Чтобы повернуть вектор, необходимо рассчитать его по следующему шаблону вращения:\\

\begin{equation*}
\begin{vmatrix}
cos(\alpha) & -sin(\alpha)\\
sin(\alpha) & cos(\alpha)
\end{vmatrix}
\end{equation*}

К сожалению, нельзя использованию плоскость камеры, которая не перпендикулярна направлению, поскольку в результате
мы получите <<косой>>, искаженный мир.

\newpage    %3 ёпта глава
\chapter{Реализация нетекстурированного движка}
Начнем с основ, то есть с нетекстурированного рейкастера. Данный пример также включает в себя счётчик fps
(число кадров в секунду) и ключи ввода с обнаружением столкновений для движения и вращения.\\

Для реализации данного движка я использовал язык C++ и графические библиотеки SDL. Работоспособность
была проверена в среде разработки $Qt~5.7$ с компилятором $gcc$ под операционными системами
$Linux~Mint~18$ и $Windows~7$\cite{straus}.\\

Как было сказанно в главе 2, карта мира представляет собой двумерный массив, где значение каждого элемента
массива является квадратом мира. Если значение ячейки равно 0, то квадрат оказывается пустым, и через него
можно пройти. Если же значение больше 0, квадрат представляет собой стену определённого цвета или текстуры.
Карта, представленная здесь, очень мала, всего 24х24 квадрата, и непосредственно определяется кодом. В
реальной игре, такой, как \textit{Wolfenstein 3D}, будет использоваться карта большего размера, которая
вместо этого будет загружаться из специального файла. Все нули в сетке являются пустыми пространствами,
потому, в исходном варианте, мы увидим очень большую комнату, обнесённую по периметру стеной (значения,
равные 1), и маленькую комнатку внутри нее (значения, равные 2), несколько столбов/колонн (значения,
равные 3), и коридор с комнатой (значения, равные 4). \\
\begin{lstlisting}
#define mapWidth 24
#define mapHeight 24

int worldMap[mapWidth][mapHeight]= \\карта
{
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};
\end{lstlisting}

Несколько первых переменных заявлены как $posX$ и $posY$, и представляют позиционный вектор игрока
(вектор его положения), в то время как переменные $dirX$ и $dirY$ задают направление игрока, а переменные
 $planeX$ и $planeY$ определяют положение камеры игрока. Необходимо убедиться в том, что плоскость
 камеры расположена перпендикулярно направлению (при этом их длину можно варьировать). Соотношение
 длины вектора направления и плоскости камеры определяет поле обзора, при этом вектор направления
 немного длиннее длины плоскости камеры, так что поле обзора будет менее 90° (точнее, поле обзора
 будет равно $2\cdot \arctan(0.66/1.0)=66°$), что идеально для шутеров от первого лица). В дальнейшем,
 при вращении с помощью входных ключей, значения векторов направления и плоскости будут меняться,
 но всегда будут оставаться перпендикулярными, и их длина также будет оставаться постоянной.\\

Переменные $time$ и $oldTime$ будут использоваться для сохранения времени текущего и предыдущего кадров.
Разница во времени между этими двумя показателями может использоваться для определения того, как далеко
можно продвинуться при нажатии одной клавиши (чтобы двигаться с постоянной скоростью, независимо от того,
как много времени занимает расчёт кадров), а также для счётчика в шутерах от первого лица.\\
\begin{lstlisting}
int main(int /*argc*/, char */*argv*/[]) {
  double posX = 22, posY = 12;  //начальная позиция x и y
  double dirX = -1, dirY = 0; //начальный вектор направления
  double planeX = 0, planeY = 0.66; //ключи 2D камеры

  double time = 0; //время текущего кадра
  double oldTime = 0; //время предыдущего кадра
\end{lstlisting}

Оставшаяся часть майновской функции начинается здесь. Сначала экран создаётся с учётом оптимального разрешения.
Если поставить большое разрешение, например, 1920*1080, эффекты будут применяться довольно медленно, не потому,
что алгоритм рейкастинга не обладает достаточной скоростью, а по той простой причине, что загрузка всего экрана
с центрального процессора на видеокарту идет достаточно медленно(вычисления производятся в ЦП а не в видеокарте).\\

\begin{lstlisting}
screen(512, 384, 0, "Raycaster");
\end{lstlisting}

После настройки экрана начинается сам цикл игры. Во время этого цикла <<рисуется>> весь кадр, и идет постоянное
считывание водимой информации.\\

\begin{lstlisting}
  while(!done()) {
\end{lstlisting}

Здесь и начинается сам рейкастинг. Цикл рейкастинга рассчитан на цикл, проходящий через каждый $x$, потому расчёт
производится не для каждого пикселя экрана, а только для каждой вертикальной полосы, что, по сути, совсем не много.
Чтобы запустить цикл рейкастинга, необходимо задать и рассчитать некоторые переменные:\\

Положение луча ($rayPos$) изначально устанавливается на основании положения игрока ($posX$, $posY$). $cameraX$ -
это координата $х$ на векторе плоскости камеры, которую представляет текущая $х$-координата экрана таким образом,
что правая сторона экрана получает координату 1, центр - координату 0, а левая сторона - снова координату 1. В
результате этого направление луча может рассчитываться, как было описано ранее, как сумма вектора направления и
части вектора плоскости. Это должно быть выполнено для координат $х$ и $у$ вектора (поскольку сложение двух
векторов означает сложение их $х$ и $у$ координат)\cite{rodgers}.\\

\begin{lstlisting}
    for(int x = 0; x < w; x++) {
//вычисление положение и направление луча
      double cameraX = 2 * x / double(w) - 1;
      //x-координата в пространстве камеры
      double rayPosX = posX;
      double rayPosY = posY;
      double rayDirX = dirX + planeX * cameraX;
      double rayDirY = dirY + planeY * cameraX;
\end{lstlisting}

В следующем отрывке кода, указывается и рассчитывается переменные для алгоритма цифрового дифференциального анализа.
$mapX$ and $mapY$ представляют текущую ячейку массива карты, в которой сейчас находится луч. Само положение луча
является числом с плавающей точкой, и содержит как информацию о том, в какой ячейке карты мы сейчас находимся, так
и о том, в какой ячейке мы находились, но $mapX$ и $mapY$ являются всего лишь координатами этой ячейки.\\

Изначально, $sideDistX$ и $sideDistY$ - это расстояние, которое нужно преодолеть лучу, чтобы пройти от его начальной
позиции до первых координат $х$ и $у$ необходимой стороны. В дальнейшем это значение в коде немного поменяется.
$deltaDistX$ и $deltaDistY$ - это расстояния, которое нужно преодолеть лучу, чтобы пройти от первой до следующей
стороны $х$, или от первой до следующей стороны $у$. Рисунок 3.1 показывает исходные $sideDistX$, $sideDistY$ и
$deltaDistX$, $deltaDistY$

\begin{figure}[h!]
\begin{center}
\includegraphics[width=5cm]{ris3_1}\\
\caption{Иллюстрация складывания луча}
\end{center}
\end{figure}

Переменная $perpWallDist$ будет использоваться в дальнейшем для расчета длины луча.

Алгоритм цифрового дифференциального анализа за один цикл всегда будет передвигаться ровно на одну ячейку в направлении
оси $х$ или $у$. В зависимости от направления луча, алгоритму может быть необходимо передвинуться в отрицательном или
положительном направлении по оси $х$ или $у$. Этот факт будет фиксироваться в $stepX$ и $stepY$. Эти переменные всегда
равны -1 либо +1.\\

Наконец, чтобы определить, может ли быть завершен данный цикл, используется факт достижения лучом одной из сторон
какой-либо ячейки. Если луч достиг стороны по оси $х$, сторона получает значение 0, если же луч достиг стороны по оси
$у$, она получает значение 1. Под сторонами по оси $х$ и $у$ подразумеваются линии решетки, которые являются границами
между двумя ячейками\cite{lode}.\\

\begin{lstlisting}
      //определение в каком квадрате карты мы находимся
      int mapX = int(rayPosX);
      int mapY = int(rayPosY);
      //длина луча от текущей позиции до следующей координаты
      double sideDistX;
      double sideDistY;ч
       //длина луча от первой координаты к следующей
      double deltaDistX = sqrt(1 + (rayDirY * rayDirY) /
      (rayDirX * rayDirX));
      double deltaDistY = sqrt(1 + (rayDirX * rayDirX) /
      (rayDirY * rayDirY));
      double perpWallDist;
      //в каком направлении к шагу в направлении (+1 или -1)
      int stepX;
      int stepY;
      int hit = 0; //был ли удар в стену?
      int side;
\end{lstlisting}

Теперь, перед началом применения алгоритма цифрового дифференциального анализа, все же необходимо рассчитать первые
$stepX$, $stepY$, а также исходные $sideDistX$ и $sideDistY$.\\

Если направление луча имеет отрицательный $х$-компонент, $stepX$ = -1, если же направление имеет положительный
$х$-компонент, $stepX$ = +1. Если же компонент равен 0, значение $stepX$ неважно, поскольку в этом случае оно
не будет использоваться. То же самое проделывается для $у$-компонента.\\

Если же направление луча имеет отрицательный $х$-компонент, $sideDistX$ представляет собой расстояние от исходной
позиции луча до до первой стороны ячейки слева, а если направление луча имеет положительный $х$-компонент - то до
первой стороны справа соответственно. То же самое проделывается для $у$-компоненты, но в этом случае берется первая
сторон сверху и снизу от исходной позиции луча. Для этих значений используется целое значение $mapX$, из которого
вычитается значение действительного положения, а затем в некоторых случаях прибавляется 1.0, в зависимости от того,
где находится задействованная сторона луча (слева или справа, сверху или снизу). Затем получаем перпендикулярное
расстояние до этой стороны, которое необходимо умножить на значение $deltaDistX$ или $deltaDistY$, чтобы получить
значение действительного наклонного расстояния.\\

\begin{lstlisting}
     //вычисление шага и первоначального sideDist
      if (rayDirX < 0){
        stepX = -1;
        sideDistX = (rayPosX - mapX) * deltaDistX;
      }
      else {
        stepX = 1;
        sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX;
      }
      if (rayDirY < 0) {
        stepY = -1;
        sideDistY = (rayPosY - mapY) * deltaDistY;
      }
      else{
        stepY = 1;
        sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY;
      }
\end{lstlisting}

Теперь начинается действие действующего цифрового дифференциального анализа(DDA). Это - цикл, с помощью которого луч
каждый раз поднимается на 1 ячейку, пока луч не достигнет стены. Каждый раз он делает скачок на расстояние,
равное 1 ячейке, в направлении оси $х$ (при $stepX$) или оси $у$ (при $stepY$). За один раз луч <<перепрыгивает>>
только одну ячейку. Если луч будет иметь направление $х$, за один цикл луч будет передвигаться только в направлении
оси $х$, поскольку координата луча $y$ в этом случае будет оставаться неизменной\cite{kotov}. Если же луч немного наклонен в
направлении оси $у$, то при каждом его передвижении по оси $х$ луч будет передвигаться также на 1 ячейку в
направлении оси $у$. Если же луч имеет чистое направление $у$, он вовсе не будет передвигаться по оси $х$, и т.д.\\

Значения $sideDistX$ и $sideDistY$ увеличиваются на $deltaDistX$ при каждом передвижении в их направлении.
Значения $mapX$ и $mapY$ также увеличиваются на $stepX$ и $stepY$ соответственно.\\

Когда луч достигнет стены, цикл окончится, и программа узнаёт, с какой стороной стены ($х$ или $у$) соприкоснулся луч в
переменной $side$, а также какой именно стены луч коснулся с $mapX$ и $mapY$. Программе не удастся точно узнать, где
именно луч коснулся стены, но в данном случае в этом нет необходимости, потому что в этом случае программа не пользуется
текстурированной стеной.\\

\begin{lstlisting}
//выполнить цифровой дифференциальный анализ
      while (hit == 0){
        //перейти на следующий квардрат в направлении х или у
        if (sideDistX < sideDistY){
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        }
        else{
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        //Проверка если луч врезался в стену
        if (worldMap[mapX][mapY] > 0)
            hit = 1;
      }
\end{lstlisting}

После выполнения цифрового дифференциального анализа необходимо рассчитать расстояние от луча до стены, чтобы
можно было вычислить, насколько высокую стену необходимо изобразить после этого. При этом не используется наклонное
расстояние: вместо этого нам необходимо значение расстояния, перпендикулярного плоскости камеры (проецируемое на
вектор направления камеры), чтобы избежать эффекта рыбьего глаза. Этот эффект возникает в том случае, если
используется реальное расстояние, так что все стены оказываются скругленными, что может вызвать головокружение
игрока при вращении\cite{chirkov}.\\

Важно отметить, что эта часть кода не является <<правкой рыбьего глаза>>, поскольку данная поправка не нужна в
представленном здесь случае использования рейкастинга. Эффекта рыбьего глаза удается избежать, просто рассчитав
расстояние, как указано выше. Данное перпендикулярное расстояние рассчитывается даже проще, чем реальное расстояние,
так как нам не нужно знать точное места, в котором луч коснулся стены.\\

Во-первых, $(1-stepX)/2$  равно 1, если $stepX$ = -1, и равно 0, если $stepX$ равна +1. Эти данные необходимы,
поскольку нам нужно добавлять 1 к длине, когда $rayDirX < 0$, по той же причине, по которой в одном случае мы
добавляли 1.0 к исходному значению $sideDistX$, а в другом случае - нет.\\

Затем расстояние рассчитывается следующим образом: если луч касается стороны $х$, $mapX-rayPosX+(1-stepX)/2)$
 - это количество ячеек, которые луч пересек в направлении оси $х$. если луч перпендикулярен оси $х$, это значение
 уже является правильным. Но поскольку в большинстве случаев направление луча различается, его реальное
 перпендикулярное расстояние будет больше, поэтому необходимо последовательно разделить его на координату $х$
 вектора $rayDir$.\\

Нечто похожее производится в случае, если луч касается стороны $у$. Рассчитанное расстояние никогда не будет
являться отрицательным числом, поскольку значение $mapX-rayPosX$ будет отрицательным только в том случае, если
$rayDirX$ было отрицательным. Затем снова будет выполнено последовательное деление этих двух значений друг на друга\cite{pavlidis}.\\

\begin{lstlisting}
//Расчёт расстояния проекции на направление камеры
//(с поправкой на эффект рыбьего глаза)
if (side == 0)
perpWallDist = (mapX - rayPosX + (1 - stepX) / 2) / rayDirX;
else
perpWallDist = (mapY - rayPosY + (1 - stepY) / 2) / rayDirY;
\end{lstlisting}

На основании рассчитанного расстояния вычисляется высота линии, которую нужно нарисовать на экране: это значение
противоположно значению $perpWallDist$, затем его необходимо умножить на $h$(высоту экрана в пикселях), чтобы
перевести значение в пиксели. Также можно умножить его на другое значение, например, на $2*h$, чтобы стена
была выше или ниже. Значение $h$ позволит создать стены, напоминающие кубы равной высоты, ширины и глубины,
в то время как крупные значения позволят создавать более высокие "коробки" (в зависимости от разрешения экрана).\\

Затем на основании значения $lineHeight$ (которое является высотой вертикальной линии, которую необходимо
нарисовать) рассчитываются начальная и конечная точки положения, где необходимо рисовать объект. Центр
стены должен при этом совпадать с центром экрана, а если эти точки находятся за пределами экрана, их максимальные
значения должны быть ограничены значениями 0 или $h-1$.\\

\begin{lstlisting}
//расчёт высоты линии для отрисовки на экране
int lineHeight = (int)(h / perpWallDist);
//вычисление самого низкого и самого высокого
//пикселя для заполнения текущей полосы
int drawStart = -lineHeight / 2 + h / 2;
if(drawStart < 0)drawStart = 0;
int drawEnd = lineHeight / 2 + h / 2;
if(drawEnd >= h)drawEnd = h - 1;
\end{lstlisting}

Наконец, в зависимости от номера стены, которой коснулся луч, выбирается цвет. Если луч коснулся стороны $у$,
выбирается более темный оттенок, что создает хороший эффект. Затем проводится вертикальная линия с помощью
метода $verLine$. После того, как данная операция была проделана, по крайней мере, в отношении всех значений
$х$, цикл рейкастинга завершается. \\

\begin{lstlisting}
//выбрать цвет стен
      ColorRGB color;
      switch(worldMap[mapX][mapY]) {
        case 1:  color = RGB_Red;  break; //красный
        case 2:  color = RGB_Green;  break; //зелёный
        case 3:  color = RGB_Blue;   break; //синий
        case 4:  color = RGB_White;  break; //белый
        default: color = RGB_Yellow; break; //жёлтый
      }
      //делаем стороны х и у разной яркости
      if (side == 1) {color = color / 2;}
      //рисуем полосу пикселей в виде вертикальной линии
      verLine(x, drawStart, drawEnd, color);
    }
\end{lstlisting}

После выполнения петли рейкастинга рассчитывается время текущей и предыдущей рамок, и показатель FPS
(количество кадров в секунду) рассчитывается и печатается; изображение на экране перерисовывается так,
что все (все стены, а также значения счётчика кадров в секунду) становятся видимыми. После этого бэкбуфер
очищается с помощью метода $cls()$, так, что когда мы снова перерисуем стены, следующая рамка, пол и
потолок снова станут чёрными, и не будут содержать пиксели из предыдущей рамки.\\

Модификаторы скорости используют $frameTime$ и постоянную величину для определения скорости движения и
вращения ключей ввода. Благодаря использованию $frameTime$, мы можем убедиться, что скорость движения и
вращения не зависит от скорости работы процессора.\\
\begin{lstlisting}
//синхронизации для входа и счетчика FPS
    oldTime = time;
    time = getTicks();
    double frameTime = (time - oldTime) / 1000.0;
    //время принятия кадра, сек
    print(1.0 / frameTime); //FPS счётчик
    redraw();
    cls();
    //модификаторы скорости
    double moveSpeed = frameTime * 5.0;
    //константная величина в квадратах / сек
    double rotSpeed = frameTime * 3.0;
    //константная величина в радианах / сек
\end{lstlisting}

Последней частью является обработка нажатий клавиш. При нажатии клавиши <<вверх>> игрок будет двигаться вперед:
прибавьте $dirX$ к $posX$, и $dirY$ к $posY$. Предполагается, что $dirX$ и $dirY$ являются нормированными
векторами (их длина равна 1). Имеется также простое встроенное условие обнаружения столкновений: если
игрок находитесь внутри стены, то он не сможете двигаться. Данное устройство обнаружения столкновений
можно улучшить, например, проверив, не будет ли врезаться в стену окружность вокруг игрока вместо всего
одной точки. То же самое происходит, если нажата клавишу <<вниз>>, но в этом случае направление вычитается\cite{java}.\\

Чтобы вращаться/поворачиваться, необходимо нажать кнопки <<влево>> или <<вправо>>. И вектор направления, и
вектор плоскости вращаются благодаря использованию формул умножения с матрицей вращения (с учетом угла $rotSpeed$).\\

\begin{lstlisting}
 readKeys();
//двигаться вперед, если впереди нет стены
if (keyDown(SDLK_UP)) {
if(worldMap[int(posX + dirX * moveSpeed)][int(posY)] == false)
posX += dirX * moveSpeed;
if(worldMap[int(posX)][int(posY + dirY * moveSpeed)] == false)
posY += dirY * moveSpeed;
}//двигаться в обратном направлении, если сзади нет стены
if (keyDown(SDLK_DOWN)) {
if(worldMap[int(posX - dirX * moveSpeed)][int(posY)] == false)
posX -= dirX * moveSpeed;
if(worldMap[int(posX)][int(posY - dirY * moveSpeed)] == false)
posY -= dirY * moveSpeed;}
//повернуть направо
if (keyDown(SDLK_RIGHT)) {
//как направление и плоскость камеры должны быть повернуты
double oldDirX = dirX;
dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
double oldPlaneX = planeX;
planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
} //повернуть влево
if (keyDown(SDLK_LEFT)) {
//как направление и плоскость камеры должны быть повернуты
double oldDirX = dirX;
dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
double oldPlaneX = planeX;
planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
} } }
\end{lstlisting}

Так завершается код нетекстурированного рейкастера. Результат на рисунке 3.2 :\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=10cm]{ris3_2}\\
\caption{Пример работы приложения}
\end{center}
\end{figure}

На рисунке 3.3 приводится пример того, что происходит, если плоскость камеры не перпендикулярна направлению вектора:
в этом случае мир "наклоняется". \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=10cm]{ris3_3}\\
\caption{Пример "неправльной" работы приложения}
\end{center}
\end{figure}

\newpage
\chapter*{ЗАКЛЮЧЕНИЕ} %ЭТО НЕНУМЕРОВАННЫЙ РАЗДЕЛ
\addcontentsline{toc}{chapter}{Заключение}
\hspace{\parindent}Для рендеринга трёхмерной картинки существует много методов, однако, методов бросания лучей являются одними
из самых простых и быстрых. С его помощью можно быстро и без особых усилий отрендерить псевдотрёхмерную картинку, получить результат
быстро и без больших вычислительных можностей. \\

Во многим, технология рейкастинга и устарела. С её помощью нельзя сделать картинку "реалестичной", пол и потолок всегда константной высоты,
плохое и малоразмерное текстурирование и тд. Но несмотря на это, метод ещё не изжил себя полностью. с его помощью можно легко
и непринуждённо переводить двухмерную карту в трёхмерный вид, например, для пожарных схем.\\

В моей курсовой работе был произведен тщательный анализ, исследование и реализация данных семейств
методов. Результатом своей работы я считаю получение основы для программного обеспечения, реализованного на данном опыте. В
дальнейшем я собираюсь и дальше развивать эту тему, и, в итоге получить программное обеспечение, по своей функциональности и
возможностям не уступающее современным инди-разработкам.\\

\newpage
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Список литературы}
\bibitem{straus} Бьерн Страуструп. Язык программирования С++(3 издание). -СПб.: Невский Диалект, 2008. - 504 с.
\bibitem{veldmanter}Вельтмандер П.В. Машинная графика. Основные алгоритмы. Книга 2.  – Новосибирск: НГУ, 1997. -197 с.
\bibitem{kotov}Котов Ю. В. Как рисует машина. — М.: Наука, 1988. — 224 с.
\bibitem{laslo}Ласло М. Вычислительная геометрия и компьютерная графика на C++. — М.: БИНОМ, 1997. — 304 с.
\bibitem{nikulin}Никулин Е. А. Компьютерная геометрия и алгоритмы машинной графики - СПб.:  БХВ-Петербург, 2003. - 554 с.
\bibitem{pavlidis}Павлидис Т. Алгоритмы машинной графики и обработки изображений: Пер. с англ. - М.: Радио и связь, 1986. – 400 с.
\bibitem{rodgers}Роджерс Д. Алгоритмические основы машинной графики. — М.: Мир, 1989. — С. 50-54
\bibitem{schirkov}Чириков С. В. Алгоритмы компьютерной графики (Методы растрирования кривых). Учебное пособие — СПб: СПбГИТМО(ТУ), 2001. — 120 с.
\bibitem{jozeph}Joseph O'Rourke. Computational Geometry in C. — Cambridge University Press, 1998. — 362 с.
\bibitem{start1}Kushner, David (2004-05-11). Masters of Doom: How Two Guys Created an Empire and Transformed Pop Culture. Random House.
\bibitem{start2}Kent, Steven L. (2010-06-16). The Ultimate History of Video Games. Three Rivers Press.
\bibitem{start3}Slaven, Andy (2002-07-01). Video Game Bible, 1985-2002. Trafford Publishing
\bibitem{lode}Lode's Computer Graphics Tutorial. 2007. URL: http://lodev.org/cgtutor/index.html
\bibitem{java}Making a Basic 3D Engine in Java. 2009. URL: http://www.instructables.com/id/Making-a-Basic-3D-Engine-in-Java/
\bibitem{raycast}RAYCASTING - сделай себе немного DOOM'a. 2004. URL: http://zxdn.narod.ru/coding/ig5ray3d.htm
\end{thebibliography}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Приложение 1}
\begin{flushright}
\large \textit{П~Р~И~Л~О~Ж~Е~Н~И~Е~1}
\end{flushright}
\begin{center}
\large \textbf{Программный код приложения для реализации метода бросания лучей}
\end{center}
\begin{lstlisting}
#include <cmath>
#include <string>
#include <vector>
#include <iostream>
#include "quickcg.h"
using namespace QuickCG;
/*
g++ *.cpp -lSDL -O3 -W -Wall -ansi -pedantic
g++ *.cpp -lSDL
*/
#define mapWidth 24 //ширина карты
#define mapHeight 24 //высота карты
int worldMap[mapWidth][mapHeight]=
{
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};
int main(int /*argc*/, char */*argv*/[]) {
  double posX = 22, posY = 12;  //начальная позиция x и y
  double dirX = -1, dirY = 0; //начальный вектор направления
  double planeX = 0, planeY = 0.66; //ключи 2D камеры
  double time = 0; //время текущего кадра
  double oldTime = 0; //время предыдущего кадра
  screen(512, 384, 0, "Raycaster");
  while(!done()) {
    for(int x = 0; x < w; x++) {
      //вычисление положение и направление луча
      double cameraX = 2 * x / double(w) - 1;
      //x-координата в пространстве камеры
      double rayPosX = posX;
      double rayPosY = posY;
      double rayDirX = dirX + planeX * cameraX;
      double rayDirY = dirY + planeY * cameraX;
      //длина луча от текущей позиции до следующей координаты
      int mapX = int(rayPosX);
      int mapY = int(rayPosY);
      //длина луча от текущей позиции до следующей координаты
      double sideDistX;
      double sideDistY;
       //длина луча от первой координаты к следующей
      double deltaDistX =
      sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX));
      double deltaDistY =
      sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY));
      double perpWallDist;
      //в каком направлении к шагу в х или у-направлении
      int stepX;
      int stepY;
      int hit = 0; //был ли удар в стену?
      int side;
      //вычисление шага и первоначального sideDist
      if (rayDirX < 0){
        stepX = -1;
        sideDistX = (rayPosX - mapX) * deltaDistX;
      }
      else {
        stepX = 1;
        sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX;
      }
      if (rayDirY < 0) {
        stepY = -1;
        sideDistY = (rayPosY - mapY) * deltaDistY;
      }
      else{
        stepY = 1;
        sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY;
      }
      //выполнить цифровой дифференциальный анализ
      while (hit == 0){
        //перейти на следующий квардрат в направлении х или у
        if (sideDistX < sideDistY){
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        }
        else{
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        //Проверка если луч врезался в стену
        if (worldMap[mapX][mapY] > 0)
            hit = 1;
      }
      //Расчёт расстояния проекции на направление камеры
	  //(устранение эффекта рыбьего глаза)
      if (side == 0)
      perpWallDist =
      (mapX - rayPosX + (1 - stepX) / 2) / rayDirX;
      else
      perpWallDist =
      (mapY - rayPosY + (1 - stepY) / 2) / rayDirY;
      //расчёт высоты линии для отрисовки на экране
      int lineHeight = (int)(h / perpWallDist);
      //вычисление самого низкого и самого высокого
	  //пикселя для заполнения текущей полосы
      int drawStart = -lineHeight / 2 + h / 2;
      if(drawStart < 0)drawStart = 0;
      int drawEnd = lineHeight / 2 + h / 2;
      if(drawEnd >= h)drawEnd = h - 1;
      //выбрать цвет стен
      ColorRGB color;
      switch(worldMap[mapX][mapY]) {
        case 1:  color = RGB_Red;  break; //красный
        case 2:  color = RGB_Green;  break; //зелёный
        case 3:  color = RGB_Blue;   break; //синий
        case 4:  color = RGB_White;  break; //белый
        default: color = RGB_Yellow; break; //жёлтый
      }
      //делаем стороны х и у разной яркости
      if (side == 1) {color = color / 2;}
      //рисуем полосу пикселей в виде вертикальной линии
      verLine(x, drawStart, drawEnd, color);
    }
    //синхронизации для входа и счетчика FPS
    oldTime = time;
    time = getTicks();
    double frameTime = (time - oldTime) / 1000.0;
    //время принятия кадра, сек
    print(1.0 / frameTime); //FPS счётчик
    redraw();
    cls();
    //модификаторы скорости
    double moveSpeed = frameTime * 5.0;
    //константная величина в квадратах / сек
    double rotSpeed = frameTime * 3.0;
    //константная величина в радианах / сек
    readKeys();
    //двигаться вперед, если впереди нет стены
    if (keyDown(SDLK_UP)) {
    if(worldMap[int(posX + dirX * moveSpeed)][int(posY)]==false)
    posX += dirX * moveSpeed;
    if(worldMap[int(posX)][int(posY + dirY*moveSpeed)]==false)
    posY += dirY * moveSpeed;
    }
    //двигаться в обратном направлении, если сзади нет стены
    if (keyDown(SDLK_DOWN)) {
    if(worldMap[int(posX - dirX * moveSpeed)][int(posY)]==false)
    posX -= dirX * moveSpeed;
    if(worldMap[int(posX)][int(posY - dirY*moveSpeed)]==false)
    posY -= dirY * moveSpeed;
    }
    //повернуть направо
    if (keyDown(SDLK_RIGHT)) {
      //как направление камеры и
      //плоскости камеры должны быть повернуты
      double oldDirX = dirX;
      dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
      dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
      double oldPlaneX = planeX;
      planeX=planeX*cos(-rotSpeed)-planeY*sin(-rotSpeed);
      planeY=oldPlaneX*sin(-rotSpeed)+planeY*cos(-rotSpeed);
    }
    //повернуть влево
    if (keyDown(SDLK_LEFT)) {
      //как направление камеры и
      //плоскости камеры должны быть повернуты
      double oldDirX = dirX;
      dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
      dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
      double oldPlaneX = planeX;
      planeX=planeX*cos(rotSpeed)-planeY*sin(rotSpeed);
      planeY=oldPlaneX*sin(rotSpeed)+planeY*cos(rotSpeed);
    }
  }
}
\end{lstlisting}
\end{document} 